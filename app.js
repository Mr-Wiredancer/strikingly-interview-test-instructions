// Generated by CoffeeScript 1.6.2
(function() {
  var DEBUG, Hangman, SbExpert, letters, requestify, util;

  requestify = require('requestify');

  util = require('util');

  SbExpert = require('./experts/sbexpert').SbExpert;

  letters = 'etaoinshrdlcumwfgypbvkjxqz';

  DEBUG = false;

  Hangman = (function() {
    function Hangman() {
      var expert, _i, _len, _ref;

      this.userId = 'lijiahao90@gmail.com';
      this.requestUrl = 'http://strikingly-interview-test.herokuapp.com/guess/process';
      this.currentWord = '';
      this.currentWordFinished = false;
      this.wordsFinished = 0;
      this.sendInitGameRequest();
      this.missed = '';
      this.letterIndex = 0;
      this.experts = [new SbExpert(this, 0)];
      this.voteCount = 0;
      this.votes = [];
      _ref = this.experts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        expert = _ref[_i];
        this.votes.push(null);
      }
    }

    Hangman.prototype.initiateGame = function(secret, numWordsGuess, numGuessesPerWord) {
      this.secret = secret;
      this.numWordsGuess = numWordsGuess;
      this.numGuessesPerWord = numGuessesPerWord;
      this.numGuessesAllowedCurrentWord = this.numGuessesPerWord;
      this.log(util.format("Hangman game %s initiated. Number of words to guess: %s; Number of guesses per word: %s", this.secret, this.numWordsGuess, this.numGuessesPerWord));
      return this.startGame();
    };

    Hangman.prototype.startGame = function() {
      return this.nextMove();
    };

    Hangman.prototype.nextMove = function() {
      if (this.currentWord === '') {
        return this.sendNextWordRequest();
      } else if (this.wordsFinished === this.numWordsGuess) {
        return this.sendGetResultRequest();
      } else if (this.currentWordFinished || (this.numGuessesAllowedCurrentWord === 0)) {
        this.wordsFinished += 1;
        this.currentWordFinished = false;
        this.missed = '';
        this.numGuessesAllowedCurrentWord = this.numGuessesPerWord;
        this.letterIndex = 0;
        return this.sendNextWordRequest();
      } else {
        DEBUG && this.log('making new guess');
        return this.callVote();
      }
    };

    Hangman.prototype.callVote = function() {
      var expert, _i, _len, _ref, _results;

      DEBUG && this.log('callVote called');
      _ref = this.experts;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        expert = _ref[_i];
        _results.push(expert.getNextGuess());
      }
      return _results;
    };

    Hangman.prototype.vote = function(choice, expertIndex) {
      DEBUG && this.log('vote called');
      this.votes[expertIndex] = choice;
      if (this.votes.indexOf(null) < 0) {
        return this.sendGuessRequest(this.getMajorityVote());
      }
    };

    Hangman.prototype.getMajorityVote = function() {
      var count, result, sortedVotes, total, vote, _i, _len, _ref;

      DEBUG && this.log('getMajorVote called');
      total = {};
      _ref = this.votes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vote = _ref[_i];
        if (total[vote]) {
          total[vote] += 1;
        } else {
          total[vote] = 1;
        }
      }
      sortedVotes = [];
      for (vote in total) {
        count = total[vote];
        sortedVotes.push({
          'vote': vote,
          'count': count
        });
      }
      sortedVotes.sort(function(a, b) {
        return b.count - a.count;
      });
      if (sortedVotes[0].vote === '?') {
        if (sortedVotes.length > 1) {
          result = sortedVotes[1].vote;
        } else {
          result = this.getNextGuess();
        }
      } else {
        result = sortedVotes[0].vote;
      }
      this.votes = (function() {
        var _j, _len1, _ref1, _results;

        _ref1 = this.votes;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          vote = _ref1[_j];
          _results.push(null);
        }
        return _results;
      }).call(this);
      return result;
    };

    Hangman.prototype.getNextGuess = function() {
      var l;

      this.letterIndex += 1;
      l = letters[this.letterIndex - 1];
      if (this.currentWord.indexOf(l) > -1 || this.missed.indexOf(l) > -1) {
        this.letterIndex += 1;
        l = letters[this.letterIndex - 1];
      }
      return l;
    };

    Hangman.prototype.sendNextWordRequest = function() {
      var game;

      this.log(util.format('%s words finished. Last word is %s', this.wordsFinished, this.currentWord));
      game = this;
      return requestify.post(this.requestUrl, {
        action: 'nextWord',
        userId: this.userId,
        secret: this.secret
      }).then(function(response) {
        var body;

        body = JSON.parse(response.body);
        if (body.status === 200) {
          DEBUG && game.log.apply(game, [body]);
          game.currentWord = body.word;
          return game.nextMove.apply(game, []);
        } else {
          game.log.apply(game, ['failed getting next word']);
          game.log.apply(game, [body]);
        }
      });
    };

    Hangman.prototype.sendGuessRequest = function(letter) {
      var game;

      DEBUG && this.log('sendGuessRequest called');
      DEBUG && this.log(util.format('current word is %s. making guess %s', this.currentWord, letter));
      game = this;
      return requestify.post(this.requestUrl, {
        action: 'guessWord',
        guess: letter.toUpperCase(),
        userId: this.userId,
        secret: this.secret
      }).then(function(response) {
        var body;

        body = JSON.parse(response.body);
        if (body.status === 200) {
          if (game.currentWord === body.word) {
            DEBUG && game.log('missed word: ' + letter);
            game.missed += letter.toUpperCase();
          }
          game.currentWord = body.word;
          if (game.isGuessSuccess.apply(game, [])) {
            game.currentWordFinished = true;
          }
          game.numGuessesAllowedCurrentWord = body.data.numberOfGuessAllowedForThisWord;
          return game.nextMove.apply(game, []);
        } else {
          game.log.apply(game, ['failed making a guess']);
          game.log.apply(game, [body]);
        }
      });
    };

    Hangman.prototype.isGuessSuccess = function() {
      return this.currentWord.indexOf('*') === -1;
    };

    Hangman.prototype.sendGetResultRequest = function() {
      var game;

      game = this;
      return requestify.post(this.requestUrl, {
        action: 'getTestResults',
        userId: this.userId,
        secret: this.secret
      }).then(function(response) {
        var body;

        body = JSON.parse(response.body);
        if (body.status === 200) {
          return game.log.apply(game, [body]);
        } else {
          game.log.apply(game, ['failed getting test results']);
          game.log.apply(game, [body]);
        }
      });
    };

    Hangman.prototype.log = function(data) {
      return console.log(data);
    };

    Hangman.prototype.sendInitGameRequest = function() {
      var game;

      game = this;
      return requestify.post(this.requestUrl, {
        action: 'initiateGame',
        userId: this.userId
      }).then(function(response) {
        var body;

        body = JSON.parse(response.body);
        if (body.status === 200) {
          return game.initiateGame.apply(game, [body.secret, body.data.numberOfWordsToGuess, body.data.numberOfGuessAllowedForEachWord]);
        } else {
          game.log.apply(game, ['failed initiating the game.']);
          game.log.apply(game, [body]);
        }
      });
    };

    return Hangman;

  })();

  global.hangman = new Hangman();

}).call(this);
